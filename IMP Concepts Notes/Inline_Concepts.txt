1. Const never used in getting the static variable ex. static size_t getTotalCars() {return totalCars_;}

2. While we want to set precision
    - use 'iomanip'
    - std::setprecision(1) // considers both left and right decimals ex. 123.34 might get print like 1e^2
    - std::fixed -> use this before set precision so that we get the fixed numbers before decimal and precision no after decimal ex. std::fixed<<std::setprecision(2)
    - Another format is scientific ex. 1.23e^2 --> use this 'cout << scientific << setprecision(2) << x << endl';

3. Now when we try to print any pointer address it is by default hexadecimal and hence non understandable. To solve this problem
    - include<cstdint>
    - and before printing address use 'uintptr_t' to convert them in decimal ex. uintptr_t(nPtr + 8)

4. Pointer to a function that takes an int and returns an int is written as ---> int (*poly)(int)
    - Passing a function pointer lets your function call other functions dynamically, without knowing exactly which function it will call at compile time.
    ex.     
            int poly1(int x) { return x*x + 2*x + 1; }       // x^2 + 2x + 1
            int poly2(int x) { return 3*x - 7; }            // 3x - 7

            int evaluate(int x, int (*poly)(int)) {
            return poly(x); // calls the function passed
            }

            int main() {
                int x = 5;S
                cout << evaluate(x, poly1) << endl; // calls poly1(5)
                cout << evaluate(x, poly2) << endl; // calls poly2(5)
            }

5. If wanted to take a random no in c++
    - include <cstdlib> (for rand() and srand())
    - include <ctime> for time
    - firstly set seed to the random time ---> std::srand(std::time(0));
    - and then easily generate the random no using this ---> std::rand()

6. Type conversion operator overloading 
    - Here we overload operators like float(), std::string() so that we can get any float value from the class
    - example:

        '''
        HybridVehicle:: operator float() const{
            return (electricKm + gasolineKm) / gasolineUsed; 
        }
        '''
    -
        We dereference this pointer
        '''
        bool HybridVehicle::operator == (const HybridVehicle& other) const{
            return (float(*this) > float(other));
        }
        '''
7. When want to write the overloading function which can read as well as to write the no in array ex arr[5] // read   and arr[5] = 50
    - In such conditions while read ("""const int& operator[](int) const;""")  // reference but constant 
    - While writing (return int&) // will return reference to change

8. In cases like we want to directly pass list of values in construictor we use initializer list
    -
    """
    Quadrilateral::Quadrilateral(std::initializer_list<float> s, std::initializer_list<float> a) {
        for(int i = 0; i < 4; i++) {
            std::copy(s.begin(),s.end(),sides);
            std::copy(a.begin(),a.end(),angles);
        }
    }
    """
    - This method is useful in such cases """ Quadrilateral quad({3,4,5,6}, {90,90,90,90});"""

9. In c++ angle always calulated ny prebuilt methods in radian degrees=radians×π/180​ this is the formulae for it

10. There are two ways we return the pointer via reference
    -
    """
    // Case 1: pointer itself is const, but value can be modified
    int* const& func1(int* const& p) {
        *p = 50;  // ✅ allowed (modify value)
        // p = nullptr; // ❌ not allowed (cannot change pointer itself)
        return p;
    }
    """
    -
    """
    // Case 2: value is const, but pointer can be modified
    const int* & func2(const int* & p) {
        static int x = 100;
        p = &x;   // ✅ allowed (change pointer)
        //*p = 200; // ❌ not allowed (value is const)
        return p;
    }
    """
    - So most of the times we return pointer by second method. By this we can change the pointer but cannot change its values

11. Using friend when we overload << and >> operator. 
    - ostream is the object of class <iostream>. We cannot call the object of another class in different class as we do not have access to private members. This is th reason to use friend function 

12. In operator overloading
    - Left-side operators (mutating) → Member functions returning reference.
    - Right-side operators (non-mutating) → Non-member functions (often friends), returning by value.

13. Operator overloading for ++ operator#include<iostream>

    """
    class addition{
        public:
            int a;
            addition( ){ a = 10; }
            void operator ++(){a ++;} // for ++ add
            void operator ++ (int) {a++;} // for add++
    };

    int main(){
        addition add;
        std::cout<<add.a<<std::endl;
        ++add;
        std::cout<<add.a<<std::endl;
        add++;
        std::cout<<add.a<<std::endl;
    }
    """

14. references must be initialized when the object is constructed.
    - hence
    """
    SimulationEngine::SimulationEngine(ConfigManager& config, FaultLogger* logger){
        this->config = config;
        this->logger = logger
    }
    """
    will give error as there is a reference which cannot be changed that is & config . hence use initializer list

15. There are three places const can appear when dealing with pointers:
    - To the left of the * → object is constant // ex. const int* p; --> You cannot modify the value being pointed to -> *p = 10; ❌ p = &x; ✅ 
    - To the right of the * → pointer itself is constant // ex. int* const p = &x; --> pointer itself is const, but the data is not -> *p = 10; ✅ p = &y; ❌
    - After the function parentheses → this function doesn’t modify the object (the this pointer is const)
    - Additional (Double Pointer) -> int** p; -> int* const* p;( you can move the outer pointer (p++), but not change where the inner pointers point)

16. That's How custom sorting algo works 
    
    """
    void DiagnosticReport::sortBySeverityDescending(){
        std::sort(collection.begin(), collection.end(), compareSeverity);
    }

    bool DiagnosticReport::compareSeverity(const SensorReading& a, const SensorReading& b) const{
        return a.getSeverity() < b.getSeverity();
    }
    """

    - starting_pointer, ending_pointer and function that how to sort 

17. Diamond problem in c++
    - When we inherit like following
     A
    / \
   B   C 
   \   / 
     D 

    - if there is a common thing in both B and C which was inherited from A then it creates ambiguity in D. that for which class common function to refer.
    // A object memory layout
    // _a

    // B object memory layout
    // _a
    // _b

    // C object memory layout
    // _a
    // _c

    // D object memory layout
    // _a --> ambiguous
    // _b
    // _a --> ambiguous
    // _c
    // _d

    - Another thing, it doesnt come until you touch A. (just creating obj (D d) --> will not give any problem, when we do d._a (i.e. Accessing ambiguity variable) it gives problem)
    - In short we can access unique variables without any issue 

    """
    class A { public: int _a; };

    class B : virtual public A { public: int _b; };
    class C : virtual public A { public: int _c; };

    class D : public B, public C { public: int _d; };
    """

    - when we inherit B and C virtually it will not cause any problem

    - Also when created of D --> it will call constructor of A first and then B and C. (IMP)

    - using virtual it tells "Hey! Only one shared copy of A should exist no matter how many times it’s inherited"
    
    - Virtual inheritance only removes ambiguity from the shared base class, but does not resolve name conflicts from the intermediate derived classes. (Similar if we define the base class method again
     in 2 classes)

18. If printing "" inside cout add '\' before ach " to add. ex. cout << "He said, \"Hello World!\"" << endl;

19. 'cctype' is libary which contains collection of character handling functions like --> isalpha() islower() etc. 
    - Here there is a function called as std::isspace(static_cast<unsigned char>(ch)) whihc will say that character is space or not'

20. C style strings contains additional null terminator. while std::string do not contain that . so we can conclude that (char ch: str) works exactly as intended

21. How to initialize other class type constructor using constructor delegation

22. Debugging C++ Code using GDB
    - 1 . compile code using g++ -g *.cpp
    - 2 . Then gdb a.out
    - 3 . Now break the using line no or function name. --> b main
    - 4 . Now to run the program --> run
    - 5 . 'f' tells you where are you. 'l' will show some part of code 
    - 6 . 'next' to go on the next line
    - 7 . 'p mainvariable' --> thats how we can print the value on any variable
    - 8 . Now if we want to go inside the function rather just execute use 'step' or 's'
    - 9 . The command 'backtrace' tells all your details that from where you have come to where you are now 
    - 10. This is how to add brekpoint to specific line no in specific file ---> b main.cpp:19
    - 11. 

23. just compile using Debugging info like above and call 'valgrind ./a.out' so that we can check if there is any memory leak

24. VVIMP :- if using pointer or pointer array inside the class, and assigning them with obj addressess created in main . problem of double deletion will 100% occur. as first delete in destructor and other delete in main. so if we are dealing with pointer in class, always declre them as pointer in main also not obj. 

25. C++ do not give permission to cast T** into (const T**) when passed to a function. so remeber to convert it using const_cast<const T**>(T**)

26. Never delete anything inside the copy constructor. 

27. = operator should aways return reference to this object not void

28. when we dont know which type of pointer we are going to reveive in function declare it as void* ex. in overloading delete operator

29. "final" keyword to avoid redefintion of particular function in c++; Declare class as final to avoid it from inheriting

30. Smart Pointers:
    - class that wraps raw pointer, to manage life time of a pointer
    - most fundamental use case of smart pointer is to remove the chances of memory leaks.
    - it make sure object is deleted if it is not used anymore

    Types:
        1. unique_ptr --> Allows only one owner of the underlying pointer
        2. shared_ptr --> Allows multiple owner of the same pointer (reference count is maintained)
        3. weak_ptr --> special type of shared_ptr which doesn't count the reference (very useful in case of cyclic dependency)

    1. unique_ptr:
        - unique_ptr is a class template
        - when unique_ptr obj goes out of the scope unique_ptr deletes it automatically.
        - similar to actual pointers we can use -> and * on the unique_ptr
        - even when exception comes it still deletes memory so that no memory leaks
        // Operations :- release , reset, swap, get, get_deleter

        - cretaing array:
            std::unique_ptr<int> arr[10];
            for(auto i=0;i<10;i++){
                arr[i] = std::make_unique<int>(i+1);
            }
            arr[0].get(); // ----> return raw pointer of std::unique_ptr
            std::unique_ptr<int>  temp = std::move(arr[2]); // 
            for(auto& i: arr){ // we can copy any pointer that's why even in loop use using the reference.
                std::cout<<*i<<std::endl;
            }
    
    2. Shared Pointer
        - can share ownership of obj (managed object)
        - several shared_ptr can point to the same object
        - it keeps shared_count to track how many pointers are pointing to the same object and one last obj gets out of the scope then managed object gets deleted.
        - shared pointer is thread safe(shared_count) and not thread safe(managed obj)
            - control block is thread safe managed object is not
        - 3 ways shared_ptr will destroy the menaged object
            - if the last pointer goes out of scope
            - if initialize shared_ptr with another shared_ptr
            - if reset shared ptr
            - reference count does not work on pointer and reference 

                cout << sp->getX() << endl; 
                cout << sp.use_count() << endl; // 1
                 std::shared_ptr<Foo> sp1 = sp;
                cout << sp.use_count() << endl;// 2
                cout << sp1.use_count() << endl;

31. inclass initialization means directly assign variables some value inside class. while memeber initialization in constructor

32. When which one is going to be get called ->  
    logVehicleByRef(v1);        // ✅ passes same object → no copy
    logVehicleByValue(v1);      // ✅ calls Copy constructor
    logVehicleByValue(Vehicle()); // ✅ temporary (rvalue) → Move constructor

33. Safe initializations means uniform initializations only at the time of first creating obj or value.

34. Imp INT things:
    1. std::uint64_t --> 64 bit unsigned int datatype for things like timestamp --> to initialize wither use static cast or use "ULL" at end of the number

35. Always rememeber array of references not allowed in c++.

36. Virtual destructor usecase: when derived object deleted via base class pointer on base class destructor runs. to avoid memory and to run both class destructors we use virtual destructor;

37. std::list<int>::const_iterator it = l.begin(); // the const_iterator ensures that we cannot modify the elements by dereferencing the iterator

        std::list<int> l = {1,2,3};

        std::list<int>::const_iterator it = l.begin();

        *it = 10;   // ❌ ERROR (read-only)
        int x = *it; // ✔ OK

38. 